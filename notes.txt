Unit 5.1: Code Generation
While writing the compiler, you're going to gain lots of very important capabilities.
In unit 4, we made a tokenizer and a parser and made legible XML code. We no longer care about that because we want to make VM code!
Each class is compiled separately, and the class level code and the subroutine code are pretty separate. Now it's just compiling a single subroutine!
Unit 5.2: Handling Variables
In order to generate actual VM code, we must know whether each variable is a field, static, local, or argument variable, and whether each variable is the first, second, or third variable of its kind.
A variable contains a name, type, kind, and scope. We will use symbol tables that contain these things. For methods only, there is an extra 'this' argument 0.
The class level symbol table will be reset whenever you change classes.
The subroutine level symbol table will be reset whenever you change subroutines.
To access variables, access the subroutine level. If we don't find it, access the class level. If we still don't, throw an error message.
Handle infinite scoping with a linked list of symbol tables.
Unit 5.3: Handling Expressions
Infix is human orientation. Prefix notation is function oriented. In the example, it has no parentheses. Postfix notation is related to our stack in VM.
To translate expressions to VM code: a) If expression is a number 'n', output push n. b) If the expression is a variable name, output push var. c) If the expression is an expression, an operator, and an expression, write the code for the first expression, then the second expression, and then push op. d) If the expression is an op and an expression, write code for the expression and output the operator. e) If the expression is a function call, write all the parameters of the function before outputting call f, where f is the function.
Unit 5.4: Handling Flow of Controls
To compile an if statement, if we compile the expression, we negate it, we if-goto label L1, compile statements1, and we go to L2. Label L1 and compile statements2, and label L2.
To compile a while expression, label L1. Compile the expressions, negate it, if-goto label L2, compile statements, and goto L1. After that, label L2.
Complications: If and while statements are often nested. Labels need to be unique.
09:38 am Thursday, November 10, 2022
[0938]â†’ Unit 5.5: Handling Objects: Low-Level Aspects
We are very fortunate that we have high-level programming-friendly languages and compilers to compile to machine language.
Object data is accessed via the 'this' segment, while array data is accessed using the 'that' segment. But before we do this, we must anchor them using the 'pointer' segment.
Unit 5.6: Handling Objects: Construction
When the compiler encounters a variable declaration, the VM code doesn't change. When we call a constructor, we push the arguments and trust that it will return the memory address in the heap.
To compile a constructor, use the function alloc() to find a memory segment with a length of the argument given.
